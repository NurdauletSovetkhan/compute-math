import numpy as np

# Gauss-Jordan Elimination
# Модификация метода Гаусса, которая приводит матрицу к единичной (диагональной) форме.
# В отличие от обычного метода Гаусса, здесь мы делаем обратный ход одновременно с прямым.
# Результат - матрица вида [I | x], где x - решение системы.
# Этот метод также используется для нахождения обратной матрицы.
# Сложность O(n³), но константа больше чем у обычного Гаусса.

def gauss_jordan(A, b):
    """
    Решение системы линейных уравнений методом Гаусса-Жордана.
    
    Параметры:
        A: матрица коэффициентов (n x n)
        b: вектор правых частей (n,)
    
    Возвращает:
        x: вектор решения (n,)
    """
    n = len(b)
    # Создаём расширенную матрицу [A | b]
    Ab = np.hstack([A.astype(float), b.reshape(-1, 1).astype(float)])
    
    # Прямой и обратный ход одновременно
    for i in range(n):
        # Частичный выбор ведущего элемента (partial pivoting)
        max_row = i + np.argmax(np.abs(Ab[i:, i]))
        if max_row != i:
            Ab[[i, max_row]] = Ab[[max_row, i]]
        
        # Проверка на вырожденность
        if abs(Ab[i, i]) < 1e-10:
            raise ValueError("Матрица вырожденная или почти вырожденная")
        
        # Нормализация ведущей строки (делаем ведущий элемент равным 1)
        Ab[i] = Ab[i] / Ab[i, i]
        
        # Обнуляем все элементы в столбце i, кроме диагонального
        for j in range(n):
            if i != j:
                factor = Ab[j, i]
                Ab[j] = Ab[j] - factor * Ab[i]
    
    # Решение находится в последнем столбце
    x = Ab[:, -1]
    
    return x


def gauss_jordan_inverse(A):
    """
    Нахождение обратной матрицы методом Гаусса-Жордана.
    
    Параметры:
        A: квадратная матрица (n x n)
    
    Возвращает:
        A_inv: обратная матрица (n x n)
    """
    n = A.shape[0]
    # Создаём расширенную матрицу [A | I]
    AI = np.hstack([A.astype(float), np.eye(n)])
    
    for i in range(n):
        # Частичный выбор ведущего элемента
        max_row = i + np.argmax(np.abs(AI[i:, i]))
        if max_row != i:
            AI[[i, max_row]] = AI[[max_row, i]]
        
        if abs(AI[i, i]) < 1e-10:
            raise ValueError("Матрица вырожденная, обратной не существует")
        
        # Нормализация
        AI[i] = AI[i] / AI[i, i]
        
        # Обнуление столбца
        for j in range(n):
            if i != j:
                factor = AI[j, i]
                AI[j] = AI[j] - factor * AI[i]
    
    # Обратная матрица находится в правой части
    A_inv = AI[:, n:]
    
    return A_inv


def solve(A, b):
    """Обёртка для унификации интерфейса."""
    return gauss_jordan(A, b)
